Git入门指导
===========

版本管理工具应有的功能
----------------------

### 基本功能

- 查看或编辑项目（单个文件或整个项目）的某个指定历史版本
- 查看项目（单个文件或整个项目）某两个历史版本的差异
- 查看项目（单个文件或整个项目）的变更记录
- 合并项目（单个文件或整个项目）的两个或多个分支版本

### 高级功能

- 权限管理（通常Git以项目为单位，控制每个开发者对每个项目的读、写、设置的权限）
- 代码审核（通过pull request）
- 依赖管理（git submodule, git subtree, repo）

Git中的一些基本概念
-------------------

### Git目录（Git Dir），工作目录（Working Tree），暂存区（Index）

Git目录是储存Git赖以工作的数据的目录，在一个普通Git项目目录（例如`demo_repo/`）中Git目录是`demo_repo/.git/`，而在一个裸Git项目（通过`git init --bare`得到）目录（通常命名为`demo_repo.git/`）中则是项目目录`demo_repo.git/`本身。通常情况下我们不需要进入该目录去查看或编辑其中的文件，而是使用`git`命令来完成大部分事情。

工作目录，准确地讲应该叫工作区，它基本上跟你项目原始的目录内容是一样的，只是底下多了一个`demo_repo/.git/`目录，这里的内容是供你查看和编辑的，它是项目的某个版本的内容的副本。你编辑工作目录下的文件并不会推进项目的演进历史，只有提交（commit）它们才会。通常你不用太过担心丢失或者弄坏了工作目录中的文件，因为你至多只会丢失尚未提交的内容，通过重置工作区命令（`git reset --hard`）你就能轻松将工作目录重置到你最后一次提交的版本。

暂存区其实简单来说，就是用来选中一些你编辑过的文件（命令是`git add {filename1} ...`）以便提交（commit）的。为什么需要这么个东西呢，因为一方面，一个提交是不一定要提交你当前修改过的所有文件的，比如你修改了a,b,c三个文件，但是a,b是修复bug1的，而c是修复bug2的，那么逻辑上，你应该创建两个提交，每个提交都修复了一个bug，但是工作的时候我们很可能是改完三个文件之后再决定提交的事情，这种情况下，暂存区就能使工作过程更加自由。

正确的姿势是这样的（在修改完a,b,c三个文件后）：

```shell
git add a b
git commit -m 'bug1 fixed.'
git add c
git commit -m 'bug2 fixed.'
```

### 块（blob），树（tree），提交（commit）

块，树和提交是Git中的三种基本对象，他们都根据其内容的哈希值（sha1）命名。其中块是跟文件系统中的文件对应的，树是跟文件系统中的目录对应的，而提交是在用户执行Git的提交命令（`git commit`）时根据提交的父提交（们）的sha1值和提交的元数据（包括提交时间，作者信息，提交注释等）创建的。

### 分支（Branch），标签（Tag），头指针（HEAD）

分支用来跟踪用户的开发过程，标签用来标记某个特定的版本，而头指针是用来记录**用户当前所在分支**的，当你执行`git checkout some_branch`命令的时候，其实就是在改变头指针所指向的分支（当然还有工作区的内容）。头指针是Git里一个非常重要的概念，当你的头指针指向某个分支的时候，一方面意味着你的所有操作都是针对这个分支的，它将成为多数常用Git命令的隐含参数，另一方面意味着你对当前工作区的文件所作的修改都是基于该分支的，当你创建提交的时候，该分支也会随之指向新的提交。

分支，标签和头指针都是引用。其中分支和标签是对提交（commit对象）的引用，而头指针通常情况下是对分支的引用（是commit对象的引用的引用），某些时候也可以直接指向commit对象（指`git checkout some_commit_id_or_some_tag`的情况），这时的头指针叫做“分离的头指针”。

分支和标签的区别在于，当你在某个分支下创建提交后，分支会自动更新指向新的提交，而标签是稳定的，不会改变它所指向的提交。由于标签不会改变它的指向，所以标签更像是某个commit id的别名。

每个引用都会对应Git目录下的一个文件，头指针对应的文件是`.git/HEAD`，而其它引用对应的文件都在`.git/refs/`目录下。另外由于标签除了引用信息外，还可能会附加注释等其它信息，所以标签还可能会对应一个`tag`类型的Git对象（也就是说，Git中有四种对象）。

### 分支的合并（merge）及衍合（rebase）

#### 分支的合并

要理解什么叫合并分支，首先要了解为什么版本历史会产生分支，这个过程其实很容易理解，假设开发者A和开发者B在从中心库R检出了相同的版本v0后，各自分别修复了一个bug并分别作了一次提交，记作v1、v2，那么从版本演化过程的逻辑来看，v1和v2是没有先后顺序的，这个时候如果没有开发者的参与，版本管理系统是无法决定v1和v2合并之后应该是什么样子的，这就是为什么需要开发者参与到分支的合并过程中来。

虽然分支合并的过程逻辑上是需要开发者的参与和确认的，但是Git会试图通过一些假设和猜测尽量地帮助你完成这个过程，那么具体是怎样的逻辑呢？

我们假设现在是从A分支合并B分支：

1. 如果A分支所指向的提交是B分支所指向的提交的祖先提交（指父提交 或 父提交的父提交 或。。。） ——还记得么，提交对象中会记录其父提交的commid id(s) ——通俗地讲就是“B比A快”，那么可以说明，B分支上的工作是建立在A分支的基础之上的，这层关系至少是经过某个开发者确认（commit）过的，因此无需你的确认（commit）Git就能认为将A分支演进至B分支处是安全的。这种情况称为快进（fast-forward）。当然如果A比B快则什么也不会发生。于是这条规则就可以简单地描述为“哪个分支快用哪个”。
2. 当两个分支分不出先后的时候，。。。。。。你可以把规则2当作是对每个文件（而不是整个提交）分别应用规则1，也就是“对于每个文件f，f在哪个分支中快，就用那个分支中的f”。这种情况会创建一个新的提交对象，并且新提交的父提交是被合并的两个分支（对，没人说过父提交只能有一个是吧）。
3. 当存在某些文件也分不出先后的时候，解决冲突的工作就不得不交给开发者了，这时Git会提示“合并发生冲突”，然后你需要编辑冲突的文件以解决冲突，再重新提交。

注：Git中的`git merge {branch}`命令，是指将branch分支的内容合并到HEAD所指的分支中，也就是说只有你所在的分支（也就是HEAD所指的分支）的版本历史会得到演进，而被合并的branch分支是不会被修改的。这就是说，merge操作对于被merge的两个分支来说，并不是对称的，所以在这篇文章中，你需要注意我的措辞：对于`git checkout A && git merge B`的情况，我会说“从A分支合并B分支”或“将B分支合并进A分支”，而不会说“合并A分支和B分支”，后者的说法让人不明所以，我曾在很多关于Git的文章中都看到过，这困扰了我很久。

#### 分支的衍合（rebase，关于中文“衍合”的译法我不知道是否恰当，只是由于没有想到合适的词，所以沿用了前人的译法）

关于衍合，有个说法是：衍合跟合并得到的结果（考虑`git merge B`和`git rebase B`）是一样的，只是产生的提交序列不一样。这个说法是正确的，但是它不能告诉我们衍合的意义是什么，什么时候应该用它，以及用它有什么好处，有什么坏处。

我希望关于衍合，大家可以从“rebase”这个词顾名思义，“base”是“基础，根据”的意思，“re-”表示“重新”，所以rebase就是重新设置基础（重设父提交）的意思。当从A衍合B的时候，我们希望做的其实是，以B为基础，把A中的工作往B上添加，怎么加呢，其实还是“谁快用谁”无法比较就交给开发者的策略，这就是为什么会有“衍合跟合并得到的结果一样，只是产生的提交序列不一样”这个说法了。

所以rebase主要有两个使用场景：
- `git pull --rebase`：我们总希望我们当前的工作是基于上游项目的最新版本的，普通的pull会使用merge而使提交历史产生分支，而`git pull --rebase`可以帮我们保证这一点（虽然我们实际上还是做了merge的工作）。
- `git rebase -i`：这条命令用来修饰你尚未推送到远端的提交序列，比如把多个提交合并成一个，更改某些提交的注释，调换某些提交的顺序，或者把某些提交分解成多个。由于这条命令需要你执行一系列相关操作来完成它，所以叫作“交互式rebase”。

### 本地分支，远程分支，上游分支（upstream）

本地分支就是指本地仓库里的分支，远程分支就是远端仓库里的分支。通常如果本地仓库是某远端仓库的克隆，那么本地仓库中的名为`origin`的远端仓库就会被自动设置。同时本地分支和远程分支是有对应关系的，也就是说本地分支会记录它的“上游分支”是源仓库中的同名分支。对于你在本地新建的分支是没有远程分支与它对应的，你可以通过在该分支下调用`git push -u {remote} {branch}`来将它提交到远端并且将远端`{branch}`分支设置为当前分支的上游分支，设置了上游分支后，你用`git status`命令的时候，就会显示当前分支与其上游分支的快慢关系了，并且你以后`git push`默认就会推送到其上游分支。

